Описание API для системы OTP
Этот документ описывает API для системы одноразовых паролей (OTP), включая эндпоинты для регистрации, аутентификации пользователей, а также для управления конфигурацией и пользователями. Предполагается, что используется RESTful API с JSON в качестве формата обмена данными.

1. Общие принципы:

Аутентификация: Использовать токен-ориентированную аутентификацию (например, JWT - JSON Web Tokens). При успешном логине возвращается токен, который клиент должен отправлять в заголовке Authorization (например, Authorization: Bearer <token>) для доступа к защищенным ресурсам.
Авторизация: На основе роли пользователя (администратор или пользователь) предоставлять или ограничивать доступ к определенным эндпоинтам. Роль пользователя должна быть закодирована в JWT-токене.
Обработка ошибок: Использовать стандартные HTTP-коды состояния для указания на успех или неудачу запроса (200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error). В теле ответа возвращать JSON с подробным описанием ошибки.
2. Эндпоинты:

2.1. Пользователи (Общие):

POST /api/users/register: Регистрация нового пользователя.
Запрос (JSON):
{
  "login": "newuser",
  "password": "securePassword",
  "role": "user"  // Должно быть "user", если администратор уже существует
}
Ответ (201 Created, JSON):
{
  "message": "User registered successfully",
  "userId": 123
}
Ответ (400 Bad Request, JSON): Если логин уже занят или недопустимые данные.
{
  "error": "Login already exists"
}
Ответ (403 Forbidden, JSON): Если пытаются зарегистрировать второго администратора.
{
   "error": "Registration of another admin user is not allowed"
}
POST /api/users/login: Логин пользователя.

Запрос (JSON):
{
  "login": "existinguser",
  "password": "password"
}
Ответ (200 OK, JSON):
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
  "expiresIn": 3600  // Время жизни токена в секундах
}
Ответ (401 Unauthorized, JSON): Если неверный логин или пароль.
{
  "error": "Invalid credentials"
}
2.2. API Администратора (/api/admin/...)

PUT /api/admin/otp-config: Изменение конфигурации OTP-кодов.

Требуется аутентификация с ролью “admin”.
Запрос (JSON):
{
  "codeLength": 8,
  "expirationTimeSeconds": 600
}
Ответ (200 OK, JSON):
{
  "message": "OTP configuration updated successfully"
}
Ответ (400 Bad Request, JSON): Если недопустимые данные.
{
  "error": "Invalid code length"
}
Ответ (403 Forbidden, JSON): Если пользователь не имеет роли “admin”.
{
  "error": "Forbidden"
}GET /api/admin/users: Получение списка всех пользователей, кроме администраторов.

Требуется аутентификация с ролью “admin”.
Ответ (200 OK, JSON):
[
  {
    "userId": 1,
    "login": "user1",
    "role": "user"
  },
  {
    "userId": 2,
    "login": "user2",
    "role": "user"
  }
]
Ответ (403 Forbidden, JSON): Если пользователь не имеет роли “admin”.
DELETE /api/admin/users/{userId}: Удаление пользователя и связанных с ним OTP-кодов.

Требуется аутентификация с ролью “admin”.
Запрос: DELETE /api/admin/users/123
Ответ (200 OK, JSON):
{
  "message": "User and associated OTP codes deleted successfully"
}
Ответ (404 Not Found, JSON): Если пользователь не найден.
json{
  "error": "User not found"
}
Ответ (403 Forbidden, JSON): Если пользователь не имеет роли “admin”.
2.3. API Пользователя (/api/user/...)

POST /api/user/otp/generate: Генерация OTP-кода.

Требуется аутентификация.
Запрос (JSON, опционально - если нужна привязка к операции):
{
  "operationId": "transaction_123" // Пример ID операции
}
Ответ (200 OK, JSON - Зависит от способа отправки. Пример для сохранения в файл):
{
  "message": "OTP code generated and saved to file",
  "otpId": "a1b2c3d4-e5f6-7890-1234-567890abcdef" // UUID OTP
}
Альтернативные ответы (200 OK, в зависимости от канала отправки):

Отправка по SMS: {"message": "OTP code sent via SMS"}
Отправка по Email: {"message": "OTP code sent via email"}
Ответ (400 Bad Request, JSON): Если произошла ошибка при генерации или отправке OTP-кода.
{
  "error": "Failed to generate OTP code"
}
POST /api/user/otp/validate: Валидация OTP-кода.

Требуется аутентификация.
Запрос (JSON):
{
  "otpId": "a1b2c3d4-e5f6-7890-1234-567890abcdef", // UUID
  "code": "123456"
}
Ответ (200 OK, JSON):
{
  "message": "OTP code validated successfully"
}
Ответ (400 Bad Request, JSON): Если OTP-код неверный, истек срок действия или уже был использован.
{
  "error": "Invalid OTP code"
}
3. Реализация:

Регистрация администратора: При первом запуске системы необходимо предоставить возможность создать первого администратора. Можно сделать это через отдельный скрипт или предусмотреть специальный флаг конфигурации. Важно, чтобы повторная регистрация администратора была невозможна через обычный API.
JWT Authentication: Использовать библиотеку для работы с JWT (например, jjwt для Java). При логине генерировать JWT-токен, включающий информацию о пользователе (логин, роль, ID) и срок действия.
Валидация токена: Перед доступом к защищенным эндпоинтам проверять подпись токена и его срок действия.
Авторизация: На основе роли пользователя в токене принимать решение о предоставлении доступа к определенным ресурсам. Реализовать middleware или аннотации для упрощения процесса авторизации.
Генерация OTP: Использовать криптографически стойкий генератор случайных чисел.
Отправка OTP: Реализовать интеграцию с SMS-сервисами, Email-сервисами и/или сохранение в файл (в зависимости от требований). При отправке учитывать возможные ошибки и предоставлять информацию об этом клиенту.
Обработка ошибок: Реализовать централизованный обработчик исключений для возврата согласованных сообщений об ошибках в формате JSON.
4. Документация:

Использовать инструменты, такие как Swagger/OpenAPI, для автоматической генерации документации API.

5. Безопасность:

HTTPS: Обязательно использовать HTTPS для защиты трафика между клиентом и сервером.
Защита от CSRF: Реализовать защиту от Cross-Site Request Forgery (CSRF) атак.
Валидация данных: Тщательно валидировать все входные данные, чтобы предотвратить SQL-инъекции и другие виды атак.
Rate limiting: Ограничить количество запросов с одного IP-адреса для защиты от атак типа “отказ в обслуживании” (DoS).
